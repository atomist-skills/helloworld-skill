import { SlackMessage } from "@atomist/slack-messages";
import { Action as SlackAction } from "@atomist/slack-messages/lib/SlackMessages";
import { GraphQLClient } from "./graphql";
import { CommandContext, EventContext, HandlerStatus } from "./handler";
import { CommandIncoming, EventIncoming, Skill, Source } from "./payload";
export interface Destinations {
    users: string | string[];
    channels: string | string[];
}
export interface MessageClient {
    send(msg: any, destinations: Destinations, options?: MessageOptions): Promise<any>;
    delete?(destinations: Destinations, options: RequiredMessageOptions): Promise<void>;
}
export interface CommandMessageClient extends MessageClient {
    respond(msg: any, options?: MessageOptions): Promise<any>;
}
export declare type RequiredMessageOptions = Pick<MessageOptions, "id" | "thread"> & {
    id: string;
};
/**
 * Options for sending messages using the MessageClient.
 */
export interface MessageOptions extends Record<string, any> {
    /**
     * Unique message id per channel and team. This is required
     * if you wish to re-write a message at a later time.
     */
    id?: string;
    /**
     * Time to live for a posted message. If ts + ttl of the
     * existing message with ts is < as a new incoming message
     * with the same id, the message will be re-written.
     */
    ttl?: number;
    /**
     * Timestamp of the message. The timestamp needs to be
     * sortable lexicographically. Should be in milliseconds and
     * defaults to Date.now().
     *
     * This is only applicable if id is set too.
     */
    ts?: number;
    /**
     * If update_only is given, this message will only be posted
     * if a previous message with the same id exists.
     */
    post?: "update_only" | "always";
    /**
     * Optional thread identifier to send this message to or true to send
     * this to the message that triggered this command.
     */
    thread?: string | boolean;
}
/** Valid MessageClient types. */
export declare const MessageMimeTypes: {
    SLACK_JSON: string;
    SLACK_FILE_JSON: string;
    PLAIN_TEXT: string;
    APPLICATION_JSON: string;
};
export declare abstract class MessageClientSupport implements MessageClient, CommandMessageClient {
    respond(msg: any, options?: MessageOptions): Promise<any>;
    send(msg: any, destinations: Destinations, options?: MessageOptions): Promise<any>;
    abstract delete(destinations: Destinations, options: RequiredMessageOptions): Promise<void>;
    protected abstract doSend(msg: any, destinations: Destinations, options?: MessageOptions): Promise<any>;
}
export declare abstract class AbstractMessageClient extends MessageClientSupport {
    protected readonly request: CommandIncoming | EventIncoming;
    protected readonly correlationId: string;
    protected readonly team: {
        id: string;
        name?: string;
    };
    protected readonly source: Source;
    protected readonly graphClient: GraphQLClient;
    constructor(request: CommandIncoming | EventIncoming, correlationId: string, team: {
        id: string;
        name?: string;
    }, source: Source, graphClient: GraphQLClient);
    delete(destinations: Destinations, options: RequiredMessageOptions): Promise<void>;
    protected doSend(msg: any, destinations: Destinations, options?: MessageOptions): Promise<any>;
    protected abstract sendResponse(response: any): Promise<void>;
    private ts;
    private getTeamId;
}
export interface CommandReferencingAction extends SlackAction {
    command: CommandReference;
}
/**
 * Information about a command handler used to connect message actions
 * to a command.
 */
export interface CommandReference {
    /**
     * The id of the action as referenced in the markup.
     */
    id: string;
    /**
     * The name of the command the button or menu should invoke
     * when selected.
     */
    name: string;
    /**
     *  List of parameters to be passed to the command.
     */
    parameters?: {
        [key: string]: any;
    };
    /**
     * Name of the parameter that should be used to pass the values
     * of the menu drop-down.
     */
    parameterName?: string;
}
export declare function mapActions(msg: SlackMessage): Action[];
export interface HandlerResponse {
    api_version: "1";
    correlation_id: any;
    team: {
        id: string;
        name?: string;
    };
    command?: string;
    event?: string;
    status?: {
        visibility?: "hidden";
        code?: number;
        reason: string;
    };
    source?: Source;
    destinations?: any[];
    content_type?: string;
    body?: string;
    id?: string;
    timestamp?: number;
    ttl?: number;
    post_mode?: "ttl" | "always" | "update_only";
    actions?: Action[];
    skill: Skill;
}
export interface Action {
    id: string;
    parameter_name?: string;
    command: string;
    parameters: Parameter[];
}
export interface Parameter {
    name: string;
    value: string;
}
export declare function isSlackMessage(object: any): object is SlackMessage;
/**
 * Message to create a Snippet in Slack
 */
export interface SlackFileMessage {
    content: string;
    title?: string;
    fileName?: string;
    fileType?: string;
    comment?: string;
}
export declare function isFileMessage(object: any): object is SlackFileMessage;
export interface StatusPublisher {
    publish(status: HandlerResponse["status"]): Promise<void>;
}
declare abstract class AbstractPubSubMessageClient extends AbstractMessageClient {
    protected readonly request: CommandIncoming | EventIncoming;
    protected readonly correlationId: string;
    protected readonly team: {
        id: string;
        name?: string;
    };
    protected readonly source: Source;
    protected readonly graphClient: GraphQLClient;
    private readonly pubsub;
    constructor(request: CommandIncoming | EventIncoming, correlationId: string, team: {
        id: string;
        name?: string;
    }, source: Source, graphClient: GraphQLClient);
    sendResponse(message: any): Promise<void>;
}
export declare class PubSubCommandMessageClient extends AbstractPubSubMessageClient implements StatusPublisher {
    protected readonly request: CommandIncoming;
    protected readonly graphClient: GraphQLClient;
    constructor(request: CommandIncoming, graphClient: GraphQLClient);
    protected doSend(msg: string | SlackMessage, destinations: Destinations, options?: MessageOptions): Promise<any>;
    publish(status: HandlerResponse["status"]): Promise<void>;
}
export declare class PubSubEventMessageClient extends AbstractPubSubMessageClient implements StatusPublisher {
    protected readonly request: EventIncoming;
    protected readonly graphClient: GraphQLClient;
    constructor(request: EventIncoming, graphClient: GraphQLClient);
    protected doSend(msg: string | SlackMessage, destinations: Destinations, options?: MessageOptions): Promise<any>;
    publish(status: HandlerResponse["status"]): Promise<void>;
}
export declare function prepareStatus(status: HandlerStatus | Error, context: EventContext | CommandContext): HandlerResponse["status"];
export {};
//# sourceMappingURL=message.d.ts.map
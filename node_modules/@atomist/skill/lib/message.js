"use strict";
/*
 * Copyright Â© 2020 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const slack_messages_1 = require("@atomist/slack-messages");
const pubsub_1 = require("@google-cloud/pubsub");
const log_1 = require("./log");
const payload_1 = require("./payload");
const util_1 = require("./util");
const cloneDeep = require("lodash.clonedeep");
/** Valid MessageClient types. */
exports.MessageMimeTypes = {
    SLACK_JSON: "application/x-atomist-slack+json",
    SLACK_FILE_JSON: "application/x-atomist-slack-file+json",
    PLAIN_TEXT: "text/plain",
    APPLICATION_JSON: "application/json",
};
class MessageClientSupport {
    respond(msg, options) {
        return this.doSend(msg, { users: [], channels: [] }, options);
    }
    send(msg, destinations, options) {
        return this.doSend(msg, destinations, options);
    }
}
exports.MessageClientSupport = MessageClientSupport;
class AbstractMessageClient extends MessageClientSupport {
    constructor(request, correlationId, team, source, graphClient) {
        super();
        this.request = request;
        this.correlationId = correlationId;
        this.team = team;
        this.source = source;
        this.graphClient = graphClient;
    }
    async delete(destinations, options) {
        return this.doSend(undefined, destinations, Object.assign(Object.assign({}, options), { delete: true }));
    }
    // tslint:disable-next-line:cyclomatic-complexity
    async doSend(msg, destinations, options = {}) {
        var _a, _b, _c, _d, _e;
        if (!!msg && msg.content_type === "application/x-atomist-continuation+json") {
            return this.sendResponse(msg).then(() => msg);
        }
        const ts = this.ts(options);
        const responseDestinations = [];
        let threadTs;
        if (options.thread === true && !!this.source) {
            threadTs = (_b = (_a = this.source) === null || _a === void 0 ? void 0 : _a.slack) === null || _b === void 0 ? void 0 : _b.message.ts;
        }
        else if (typeof options.thread === "string") {
            threadTs = options.thread;
        }
        const teamId = await this.getTeamId((_e = (_d = (_c = this.source) === null || _c === void 0 ? void 0 : _c.slack) === null || _d === void 0 ? void 0 : _d.team) === null || _e === void 0 ? void 0 : _e.id, this.graphClient);
        util_1.toArray(destinations.users || []).forEach(d => {
            responseDestinations.push({
                user_agent: "slack",
                slack: {
                    team: {
                        id: teamId,
                    },
                    user: {
                        name: d,
                    },
                    thread_ts: threadTs,
                },
            });
        });
        util_1.toArray(destinations.channels || []).forEach(d => {
            responseDestinations.push({
                user_agent: "slack",
                slack: {
                    team: {
                        id: teamId,
                    },
                    channel: {
                        name: d,
                    },
                    thread_ts: threadTs,
                },
            });
        });
        if (responseDestinations.length === 0 && this.source) {
            const responseDestination = cloneDeep(this.source);
            if (responseDestination.slack) {
                delete responseDestination.slack.user;
                if (threadTs) {
                    responseDestination.slack.thread_ts = threadTs;
                }
            }
            responseDestinations.push(responseDestination);
        }
        const response = {
            api_version: "1",
            correlation_id: this.correlationId,
            team: this.team,
            source: this.source ? this.source : undefined,
            command: payload_1.isCommandIncoming(this.request) ? this.request.command : undefined,
            event: payload_1.isEventIncoming(this.request) ? this.request.extensions.operationName : undefined,
            destinations: responseDestinations,
            id: options.id ? options.id : undefined,
            timestamp: ts,
            ttl: ts && options.ttl ? options.ttl : undefined,
            post_mode: options.post === "update_only" ? "update_only" : (options.post === "always" ? "always" : "ttl"),
            skill: this.request.skill,
        };
        if (isSlackMessage(msg)) {
            const msgClone = cloneDeep(msg);
            const actions = mapActions(msgClone);
            response.content_type = exports.MessageMimeTypes.SLACK_JSON;
            response.body = slack_messages_1.render(msgClone, false);
            response.actions = actions;
        }
        else if (isFileMessage(msg)) {
            response.content_type = exports.MessageMimeTypes.SLACK_FILE_JSON;
            response.body = JSON.stringify({
                content: msg.content,
                filename: msg.fileName,
                filetype: msg.fileType,
                title: msg.title,
                initial_comment: msg.comment,
            });
        }
        else if (typeof msg === "string") {
            response.content_type = exports.MessageMimeTypes.PLAIN_TEXT;
            response.body = msg;
        }
        else if (options.delete) {
            response.content_type = "application/x-atomist-delete";
            response.body = undefined;
        }
        return this.sendResponse(response).then(() => response);
    }
    ts(options) {
        if (options.id) {
            if (options.ts) {
                return options.ts;
            }
            else {
                return Date.now();
            }
        }
        else {
            return undefined;
        }
    }
    async getTeamId(teamId, graphClient) {
        var _a;
        if (teamId) {
            return teamId;
        }
        else {
            const query = `query ChatTeam { ChatTeam { id } }`;
            const result = await graphClient.query(query);
            return (_a = result === null || result === void 0 ? void 0 : result.ChatTeam[0]) === null || _a === void 0 ? void 0 : _a.id;
        }
    }
}
exports.AbstractMessageClient = AbstractMessageClient;
function mapActions(msg) {
    const actions = [];
    let counter = 0;
    if (msg.attachments) {
        msg.attachments.filter(attachment => attachment.actions).forEach(attachment => {
            attachment.actions.forEach(a => {
                if (!!a && !!a.command) {
                    const cra = a;
                    const id = counter++;
                    cra.command.id = `${cra.command.id}-${id}`;
                    a.name = `${a.name}-${id}`;
                    const action = {
                        id: cra.command.id,
                        parameter_name: cra.command.parameterName,
                        command: cra.command.name,
                        parameters: mapParameters(cra.command.parameters),
                    };
                    actions.push(action);
                    // Lastly we need to delete our extension from the slack action
                    cra.command = undefined;
                }
            });
        });
    }
    return actions;
}
exports.mapActions = mapActions;
function mapParameters(data) {
    const parameters = [];
    for (const key in data) {
        const value = data[key];
        if (value) {
            parameters.push({
                name: key,
                value: value.toString(),
            });
        }
        else {
            // logger.debug(`Parameter value for '${key}' is null`);
        }
    }
    return parameters;
}
function isSlackMessage(object) {
    return !!object && (object.text || object.attachments || object.blocks) && !object.content;
}
exports.isSlackMessage = isSlackMessage;
function isFileMessage(object) {
    return !!object && !object.length && object.content;
}
exports.isFileMessage = isFileMessage;
class AbstractPubSubMessageClient extends AbstractMessageClient {
    constructor(request, correlationId, team, source, graphClient) {
        super(request, correlationId, team, source, graphClient);
        this.request = request;
        this.correlationId = correlationId;
        this.team = team;
        this.source = source;
        this.graphClient = graphClient;
        this.pubsub = new pubsub_1.PubSub();
    }
    async sendResponse(message) {
        const topicName = process.env.ATOMIST_TOPIC || process.env.TOPIC;
        try {
            log_1.debug(`Sending message: ${JSON.stringify(message, util_1.replacer)}`);
            if (topicName) {
                const topic = this.pubsub.topic(topicName);
                const messageBuffer = Buffer.from(JSON.stringify(message), "utf8");
                await topic.publish(messageBuffer);
            }
        }
        catch (err) {
            log_1.error(`Error occurred sending message: ${err.message}`);
        }
    }
}
class PubSubCommandMessageClient extends AbstractPubSubMessageClient {
    constructor(request, graphClient) {
        super(request, request.correlation_id, request.team, request.source, graphClient);
        this.request = request;
        this.graphClient = graphClient;
    }
    async doSend(msg, destinations, options = {}) {
        return super.doSend(msg, destinations, options);
    }
    async publish(status) {
        const source = cloneDeep(this.request.source);
        if (source && source.slack) {
            delete source.slack.user;
        }
        const response = {
            api_version: "1",
            correlation_id: this.request.correlation_id,
            team: this.request.team,
            command: this.request.command,
            source: this.request.source,
            destinations: [source],
            status,
            skill: this.request.skill,
        };
        return this.sendResponse(response);
    }
}
exports.PubSubCommandMessageClient = PubSubCommandMessageClient;
class PubSubEventMessageClient extends AbstractPubSubMessageClient {
    constructor(request, graphClient) {
        super(request, request.extensions.correlation_id, { id: request.extensions.team_id, name: request.extensions.team_name }, undefined, graphClient);
        this.request = request;
        this.graphClient = graphClient;
    }
    async doSend(msg, destinations, options = {}) {
        return super.doSend(msg, destinations, options);
    }
    async publish(status) {
        const response = {
            api_version: "1",
            correlation_id: this.request.extensions.correlation_id,
            team: {
                id: this.request.extensions.team_id,
                name: this.request.extensions.team_name,
            },
            event: this.request.extensions.operationName,
            status,
            skill: this.request.skill,
        };
        return this.sendResponse(response);
    }
}
exports.PubSubEventMessageClient = PubSubEventMessageClient;
function prepareStatus(status, context) {
    if (status instanceof Error) {
        return {
            code: 1,
            reason: `Error invoking ${context.skill.namespace}/${context.skill.name}`,
        };
    }
    else {
        const reason = `${(status === null || status === void 0 ? void 0 : status.code) === 0 ? "Successfully" : "Unsuccessfully"} invoked ${context.skill.namespace}/${context.skill.name}`;
        return {
            visibility: status === null || status === void 0 ? void 0 : status.visibility,
            code: (status === null || status === void 0 ? void 0 : status.code) || 0,
            reason: (status === null || status === void 0 ? void 0 : status.reason) || reason,
        };
    }
}
exports.prepareStatus = prepareStatus;
//# sourceMappingURL=message.js.map
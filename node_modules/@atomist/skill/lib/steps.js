"use strict";
/*
 * Copyright Â© 2020 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const skill_logging_1 = require("@atomist/skill-logging");
const log_1 = require("./log");
const util_1 = require("./util");
/**
 * Execute provided skill steps in the order they are provided or until one fails
 */
async function runSteps(options) {
    const parameters = {};
    const context = options.context;
    const listeners = util_1.toArray(options.listeners) || [];
    let result;
    for (const step of util_1.toArray(options.steps)) {
        try {
            if (!step.runWhen || !!(await step.runWhen(context, parameters))) {
                await context.audit.log(`Running '${step.name}'`);
                await invokeListeners(listeners.filter(l => !!l.starting), async (l) => l.starting(step, parameters));
                const sr = await step.run(context, parameters);
                if (sr) {
                    result = sr;
                }
                await invokeListeners(listeners.filter(l => !!l.completed), async (l) => l.completed(step, parameters, sr));
                if (!!sr && sr.code !== 0) {
                    await context.audit.log(`'${step.name}' errored with: ${sr.reason}`, skill_logging_1.Severity.ERROR);
                    return sr;
                }
                else if (!!sr && !!sr.reason) {
                    await context.audit.log(`Completed '${step.name}' with: ${sr.reason}`);
                }
                else {
                    await context.audit.log(`Completed '${step.name}'`);
                }
            }
            else {
                await context.audit.log(`Skipping '${step.name}'`);
                await invokeListeners(listeners.filter(l => !!l.skipped), async (l) => l.skipped(step, parameters));
            }
        }
        catch (e) {
            await context.audit.log(`'${step.name}' errored with: ${e.message}`, skill_logging_1.Severity.ERROR);
            await context.audit.log(e.stack, skill_logging_1.Severity.ERROR);
            await invokeListeners(listeners.filter(l => !!l.failed), async (l) => l.failed(step, parameters, e));
            log_1.warn(`'${step.name}' errored with:`);
            log_1.warn(e.stack);
            return {
                code: 1,
                reason: `'${step.name}' errored`,
            };
        }
    }
    return invokeDone(listeners.filter(l => !!l.done), parameters, result);
}
exports.runSteps = runSteps;
async function invokeListeners(listeners, cb) {
    for (const listener of listeners) {
        try {
            await cb(listener);
        }
        catch (e) {
            log_1.warn("Listener failed with");
            log_1.warn(e);
        }
    }
}
async function invokeDone(listeners, parameters, inputResult) {
    let result = inputResult;
    for (const listener of listeners) {
        try {
            result = await listener.done(parameters, result);
        }
        catch (e) {
            log_1.warn("Listener failed with:");
            log_1.warn(e);
        }
    }
    return result;
}
//# sourceMappingURL=steps.js.map
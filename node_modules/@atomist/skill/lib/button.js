"use strict";
/*
 * Copyright Â© 2020 Atomist, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const flat_1 = require("flat");
const merge = require("lodash.merge");
const forOwn = require("lodash.forown");
/**
 * Create a slack button that invokes a command handler.
 */
function buttonForCommand(buttonSpec, command, parameters = {}) {
    const params = mergeParameters(command, parameters);
    const id = command.toLocaleLowerCase();
    const action = chatButtonFrom(buttonSpec, { id });
    action.command = {
        id,
        name: command,
        parameters: params,
    };
    return action;
}
exports.buttonForCommand = buttonForCommand;
/**
 * Create a Slack menu that invokes a command handler.
 */
function menuForCommand(selectSpec, command, parameterName, parameters = {}) {
    const params = mergeParameters(command, parameters);
    const id = command.toLocaleLowerCase();
    const action = chatMenuFrom(selectSpec, { id, parameterName });
    action.command = {
        id,
        name: command,
        parameters: params,
        parameterName,
    };
    return action;
}
exports.menuForCommand = menuForCommand;
/**
 * Merge the provided parameters into any parameters provided as
 * command object instance variables.
 */
function mergeParameters(command, parameters) {
    // Reuse parameters defined on the instance
    if (typeof command !== "string" && typeof command !== "function") {
        const newParameters = merge(command, parameters);
        return flat_1.flatten(newParameters);
    }
    return flat_1.flatten(parameters);
}
exports.mergeParameters = mergeParameters;
function chatButtonFrom(action, command) {
    if (!command.id) {
        throw new Error(`Please provide a valid non-empty command id`);
    }
    const button = {
        text: action.text,
        type: "button",
        name: `automation-command::${command.id}`,
    };
    forOwn(action, (v, k) => {
        button[k] = v;
    });
    return button;
}
function chatMenuFrom(action, command) {
    if (!command.id) {
        throw new Error("SelectableIdentifiableInstruction must have id set");
    }
    if (!command.parameterName) {
        throw new Error("SelectableIdentifiableInstruction must have parameterName set");
    }
    const select = {
        text: action.text,
        type: "select",
        name: `automation-command::${command.id}`,
    };
    if (typeof action.options === "string") {
        select.data_source = action.options;
    }
    else if (action.options.length > 0) {
        const first = action.options[0];
        if (first.value) {
            // then it's normal options
            select.options = action.options;
        }
        else {
            // then it's option groups
            select.option_groups = action.options;
        }
    }
    forOwn(action, (v, k) => {
        if (k !== "options") {
            select[k] = v;
        }
    });
    return select;
}
//# sourceMappingURL=button.js.map